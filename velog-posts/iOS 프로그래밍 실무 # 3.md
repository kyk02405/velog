<hr />
<h1 id="무드등-어플-사전계획서">무드등 어플 사전계획서</h1>
<h3 id="1-시장-조사">1. 시장 조사</h3>
<p>현재 앱스토어에는 다양한 야간 조명 앱이 존재하며, 각기 다른 기능과 디자인을 제공합니다. 이러한 앱들의 주요 기능과 특징을 분석하여 차별화된 기능을 도출하는 것이 필요합니다.</p>
<p><strong>참고할 인기 앱:</strong></p>
<ul>
<li><strong>Night Light Pro</strong></li>
<li><strong>Night Light Lite</strong></li>
<li><strong>Sleep Tight Night Light</strong></li>
</ul>
<h3 id="2-주요-기능-정의">2. 주요 기능 정의</h3>
<p>앱의 핵심 기능은 다음과 같습니다:</p>
<ul>
<li><strong>조명 색상 및 밝기 조절:</strong> 사용자가 다양한 색상과 밝기를 선택하여 개인의 취향과 필요에 맞게 설정할 수 있도록 합니다.</li>
<li><strong>타이머 기능:</strong> 지정한 시간이 지나면 자동으로 조명이 꺼지도록 설정할 수 있습니다.</li>
<li><strong>백색 소음 및 자장가:</strong> 수면을 도와주는 백색 소음이나 자장가를 재생하는 기능을 추가하여 사용자에게 편안한 수면 환경을 제공합니다.</li>
<li><strong>광고 제거 옵션:</strong> 사용자 경험을 향상시키기 위해 광고 제거 기능을 유료 옵션으로 제공합니다.</li>
</ul>
<h3 id="3-디자인-및-사용자-경험">3. 디자인 및 사용자 경험</h3>
<ul>
<li><strong>심플하고 직관적인 인터페이스:</strong> 사용자가 쉽게 조작할 수 있도록 간결한 디자인을 채택합니다.</li>
<li><strong>다양한 테마 제공:</strong> 사용자의 취향에 맞게 다양한 테마를 제공하여 앱의 개인화 기능을 강화합니다.</li>
<li><strong>애니메이션 효과:</strong> 부드러운 애니메이션을 통해 시각적인 만족감을 제공합니다.</li>
</ul>
<h3 id="4-기술-스택">4. 기술 스택</h3>
<ul>
<li><strong>개발 언어:</strong> Swift</li>
<li><strong>개발 도구:</strong> Xcode</li>
<li><strong>지원 버전:</strong> iOS 14 이상</li>
</ul>
<h3 id="5-마케팅-전략">5. 마케팅 전략</h3>
<ul>
<li><strong>SNS 마케팅:</strong> 인스타그램, 페이스북 등 소셜 미디어를 활용하여 앱을 홍보합니다.</li>
<li><strong>인플루언서 협업:</strong> 수면 관련 콘텐츠를 제작하는 인플루언서와 협업하여 앱을 소개합니다.</li>
<li><strong>프로모션 이벤트:</strong> 초기 다운로드 사용자에게 프리미엄 기능을 일정 기간 무료로 제공하는 이벤트를 진행합니다.</li>
</ul>
<h3 id="6-수익-모델">6. 수익 모델</h3>
<ul>
<li><strong>광고 수익:</strong> 앱 내 배너 및 전면 광고를 통해 수익을 창출합니다.</li>
<li><strong>인앱 구매:</strong> 프리미엄 기능(예: 광고 제거, 추가 테마 등)을 유료로 제공합니다.</li>
</ul>
<h3 id="7-개발-일정">7. 개발 일정</h3>
<ol>
<li><strong>1주차:</strong> 시장 조사 및 기획</li>
<li><strong>2-4주차:</strong> 디자인 및 프로토타입 제작</li>
<li><strong>5-8주차:</strong> 개발 및 테스트</li>
<li><strong>9-10주차:</strong> 베타 테스트 및 피드백 반영</li>
<li><strong>11-12주차:</strong> 앱스토어 등록 및 마케팅 시작</li>
</ol>
<hr />
<h1 id="25년-5월31일까지-개발-일정">25년 5월31일까지 개발 일정</h1>
<h3 id="ios-night-light-앱-개발-일정-마감-2025년-5월-31일"><strong>iOS Night Light 앱 개발 일정 (마감: 2025년 5월 31일)</strong></h3>
<h4 id="📌-전체-일정-개요"><strong>📌 전체 일정 개요</strong></h4>
<ul>
<li><strong>개발 시작:</strong> 2025년 3월 25일  </li>
<li><strong>개발 완료:</strong> 2025년 5월 31일  </li>
<li><strong>총 기간:</strong> 약 10주  </li>
</ul>
<hr />
<h3 id="🔹-주요-일정-주별-계획"><strong>🔹 주요 일정 (주별 계획)</strong></h3>
<h4 id="1️⃣-1주차-3월-25일--3월-31일--기획-및-시장-조사"><strong>1️⃣ 1주차 (3월 25일 ~ 3월 31일) – 기획 및 시장 조사</strong></h4>
<p>✅ 앱스토어 인기 야간 조명 앱 분석<br />✅ 핵심 기능 및 차별점 도출<br />✅ 개발 목표 및 수익 모델 확정  </p>
<h4 id="2️⃣-23주차-4월-1일--4월-14일--uiux-디자인-및-프로토타입-제작"><strong>2️⃣ 2~3주차 (4월 1일 ~ 4월 14일) – UI/UX 디자인 및 프로토타입 제작</strong></h4>
<p>✅ 와이어프레임 및 UI 설계 (Figma 등 사용)<br />✅ iOS 디자인 가이드라인 적용<br />✅ 프로토타입 제작 및 피드백 반영  </p>
<h4 id="3️⃣-46주차-4월-15일--5월-5일--기능-개발"><strong>3️⃣ 4~6주차 (4월 15일 ~ 5월 5일) – 기능 개발</strong></h4>
<p>✅ <strong>(4주차)</strong> 기본 조명 기능 구현 (색상 변경, 밝기 조절)<br />✅ <strong>(5주차)</strong> 타이머 기능 및 애니메이션 효과 추가<br />✅ <strong>(6주차)</strong> 백색 소음 및 자장가 기능 추가  </p>
<h4 id="4️⃣-7주차-5월-6일--5월-12일--테스트-및-버그-수정-1차-qa"><strong>4️⃣ 7주차 (5월 6일 ~ 5월 12일) – 테스트 및 버그 수정 (1차 QA)</strong></h4>
<p>✅ iOS 기기별 테스트 (iPhone, iPad)<br />✅ 주요 버그 수정 및 최적화  </p>
<h4 id="5️⃣-8주차-5월-13일--5월-19일--인앱-구매-및-광고-시스템-적용"><strong>5️⃣ 8주차 (5월 13일 ~ 5월 19일) – 인앱 구매 및 광고 시스템 적용</strong></h4>
<p>✅ 광고 삽입 및 비즈니스 모델 적용<br />✅ 유료 기능 (프리미엄 테마, 광고 제거) 개발  </p>
<h4 id="6️⃣-9주차-5월-20일--5월-26일--최종-테스트-및-앱스토어-심사-준비"><strong>6️⃣ 9주차 (5월 20일 ~ 5월 26일) – 최종 테스트 및 앱스토어 심사 준비</strong></h4>
<p>✅ 앱스토어 등록 준비 (앱 아이콘, 스크린샷, 설명 작성)<br />✅ TestFlight 배포 후 베타 테스터 피드백 반영<br />✅ 최종 버그 수정 및 성능 개선  </p>
<h4 id="7️⃣-10주차-5월-27일--5월-31일--앱스토어-제출-및-출시-준비"><strong>7️⃣ 10주차 (5월 27일 ~ 5월 31일) – 앱스토어 제출 및 출시 준비</strong></h4>
<p>✅ 앱스토어 심사 요청<br />✅ 출시 전 마케팅 콘텐츠 제작 및 홍보<br />✅ 출시 후 초기 피드백 반영 계획 수립  </p>
<hr />
<h3 id="📌-기타-고려사항"><strong>📌 기타 고려사항</strong></h3>
<ul>
<li><strong>중간 점검:</strong> 4월 30일 (기능 개발 80% 완료 목표)  </li>
<li><strong>앱스토어 심사 기간 고려:</strong> 보통 2~3일 소요되지만, 지연 가능성을 고려하여 5월 27일까지 제출 완료  </li>
</ul>
<p>이 일정에 따라 진행하면 <strong>2025년 5월 31일까지</strong> 앱을 안정적으로 출시할 수 있을 것입니다. 🚀</p>
<hr />
<h1 id="📌-night-light-ios-앱-개발-분담표"><strong>📌 Night Light iOS 앱 개발 분담표</strong></h1>
<p><strong>팀원 구성:</strong></p>
<ol>
<li><strong>A (iOS 개발 담당)</strong></li>
<li><strong>B (UI/UX 디자인 &amp; 프론트엔드)</strong></li>
<li><strong>C (백엔드 &amp; 데이터 처리)</strong>  </li>
</ol>
<hr />
<h3 id="🔹-역할-및-담당-업무"><strong>🔹 역할 및 담당 업무</strong></h3>
<table>
<thead>
<tr>
<th><strong>업무</strong></th>
<th><strong>A (iOS 개발)</strong></th>
<th><strong>B (UI/UX 디자인 &amp; 프론트엔드)</strong></th>
<th><strong>C (백엔드 &amp; 데이터 처리)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 기획 및 시장 조사</strong></td>
<td>✅ 참여</td>
<td>✅ 리서치 &amp; 디자인 참고 자료 정리</td>
<td>✅ 데이터베이스 및 API 분석</td>
</tr>
<tr>
<td><strong>2. UI/UX 디자인</strong></td>
<td></td>
<td>✅ Figma로 디자인 제작</td>
<td></td>
</tr>
<tr>
<td><strong>3. 프로토타입 제작</strong></td>
<td></td>
<td>✅ SwiftUI / UIKit 프로토타입</td>
<td>✅ API 연동 검토</td>
</tr>
<tr>
<td><strong>4. 기본 기능 개발</strong></td>
<td>✅ 조명 색상 변경, 밝기 조절</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>5. 타이머 기능 개발</strong></td>
<td>✅</td>
<td></td>
<td>✅ 데이터 저장 방식 결정</td>
</tr>
<tr>
<td><strong>6. 백색 소음 / 자장가 기능</strong></td>
<td>✅ 오디오 플레이어 구현</td>
<td>✅ 오디오 UI 디자인</td>
<td>✅ 백엔드에서 사운드 파일 관리</td>
</tr>
<tr>
<td><strong>7. 광고 및 인앱 결제</strong></td>
<td>✅ AdMob, 결제 모듈 적용</td>
<td>✅ UI 구성</td>
<td>✅ 결제 데이터 처리</td>
</tr>
<tr>
<td><strong>8. 앱 최적화 및 버그 수정</strong></td>
<td>✅ Xcode Debugging</td>
<td>✅ UI 최적화</td>
<td>✅ 백엔드 최적화</td>
</tr>
<tr>
<td><strong>9. 앱스토어 등록 준비</strong></td>
<td>✅ 빌드 제출</td>
<td>✅ 스크린샷, 설명 작성</td>
<td>✅ 서버 안정성 점검</td>
</tr>
<tr>
<td><strong>10. 출시 후 유지보수</strong></td>
<td>✅ 업데이트</td>
<td>✅ UI 개선</td>
<td>✅ 서버 관리 및 성능 개선</td>
</tr>
</tbody></table>
<hr />
<h3 id="🔹-주별-분담-일정"><strong>🔹 주별 분담 일정</strong></h3>
<table>
<thead>
<tr>
<th>주차</th>
<th>A (iOS 개발)</th>
<th>B (UI/UX 디자인)</th>
<th>C (백엔드)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1주차 (3/25~3/31)</strong></td>
<td>기획 참여</td>
<td>시장 조사 및 와이어프레임</td>
<td>데이터베이스 구조 설계</td>
</tr>
<tr>
<td><strong>2<del>3주차 (4/1</del>4/14)</strong></td>
<td>Swift 기반 프로젝트 생성, 기본 레이아웃 구현</td>
<td>Figma로 디자인 완성</td>
<td>API 설계 및 테스트</td>
</tr>
<tr>
<td><strong>4<del>6주차 (4/15</del>5/5)</strong></td>
<td>주요 기능 개발 (조명, 타이머, 오디오)</td>
<td>디자인 피드백 및 UI 보완</td>
<td>백엔드 연동 시작</td>
</tr>
<tr>
<td><strong>7주차 (5/6~5/12)</strong></td>
<td>테스트 및 버그 수정</td>
<td>UI 최적화</td>
<td>API 테스트 및 데이터 연동</td>
</tr>
<tr>
<td><strong>8주차 (5/13~5/19)</strong></td>
<td>광고, 인앱 결제 적용</td>
<td>UI/UX 최종 보완</td>
<td>데이터 처리 마무리</td>
</tr>
<tr>
<td><strong>9주차 (5/20~5/26)</strong></td>
<td>TestFlight 배포, 최종 버그 수정</td>
<td>앱스토어 마케팅 자료 제작</td>
<td>서버 안정성 점검</td>
</tr>
<tr>
<td><strong>10주차 (5/27~5/31)</strong></td>
<td>앱스토어 제출</td>
<td>출시 후 홍보</td>
<td>서버 모니터링</td>
</tr>
</tbody></table>
<hr />
<p>이 분담표에 따라 각자 역할을 수행하면 <strong>효율적으로 협업하면서 5월 31일까지 앱 출시가 가능</strong>할 것입니다. 🚀</p>
<hr />
<h1 id="xcode-general-tap">Xcode General Tap</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/3eeba0d9-f6ca-41d2-bc42-c1ca5c0ac55f/image.png" /></p>
<p>이 스크린샷은 <strong>Xcode의 프로젝트 설정(Project Settings) 화면</strong>입니다.<br />특히 <strong>iOS 앱의 배포 및 기본 설정(Deployment &amp; Identity)</strong>을 보여주고 있습니다.<br />각 항목을 설명해 드리겠습니다.</p>
<hr />
<h3 id="📌-minimum-deployments-최소-배포-버전"><strong>📌 Minimum Deployments (최소 배포 버전)</strong></h3>
<ul>
<li><strong>iOS 16.0</strong><br />→ 이 앱은 iOS <strong>16.0 이상</strong>에서만 실행될 수 있습니다.<br />→ 즉, iOS 15 이하의 기기에서는 설치 및 실행이 불가능합니다.</li>
</ul>
<hr />
<h3 id="📌-identity-앱의-고유-정보"><strong>📌 Identity (앱의 고유 정보)</strong></h3>
<ul>
<li><p><strong>App Category</strong>: <code>None</code><br />→ 앱의 카테고리가 아직 지정되지 않았습니다.<br />→ App Store에 배포할 경우 적절한 카테고리를 설정해야 합니다.  </p>
</li>
<li><p><strong>Display Name</strong>: <code>Display Name</code><br />→ 앱이 iPhone/iPad 화면에서 표시될 이름입니다.<br />→ 아직 설정되지 않았으며, 앱 이름을 입력해야 합니다.  </p>
</li>
<li><p><strong>Bundle Identifier</strong>: <code>kr.ac.induk.kyk.NightLight</code><br />→ 앱의 고유 식별자입니다.<br />→ 일반적으로 <code>도메인 거꾸로 + 프로젝트명</code> 형식으로 구성됩니다.<br />→ <code>kr.ac.induk.kyk</code>는 <code>인덕대학교</code>의 특정 개발자가 만든 <strong>NightLight</strong> 앱을 의미합니다.  </p>
</li>
<li><p><strong>Version</strong>: <code>1.0</code><br />→ 현재 앱의 <strong>버전(Version) 정보</strong>입니다.<br />→ <code>1.0</code>은 첫 번째 정식 버전입니다.  </p>
</li>
<li><p><strong>Build</strong>: <code>1</code><br />→ 현재 빌드(Build) 번호입니다.<br />→ 버그 수정이나 업데이트 시 <code>1 → 2 → 3</code> 등으로 증가시킵니다.  </p>
</li>
</ul>
<hr />
<h3 id="📌-deployment-info-배포-정보"><strong>📌 Deployment Info (배포 정보)</strong></h3>
<ul>
<li><p><strong>iPhone Orientation (iPhone 화면 방향 지원)</strong></p>
<ul>
<li>☑ <strong>Portrait (세로 모드)</strong></li>
<li>☐ <strong>Upside Down (거꾸로 세로 모드)</strong> (비활성화됨)</li>
<li>☑ <strong>Landscape Left (가로 모드 - 왼쪽)</strong></li>
<li>☑ <strong>Landscape Right (가로 모드 - 오른쪽)</strong>  </li>
</ul>
<p>→ 현재 설정에 따르면 <strong>세로 모드 + 가로 모드(좌우 회전 포함)만 허용</strong><br />→ 그러나 <strong>거꾸로 세로 모드(위아래 반전)는 지원하지 않음</strong>  </p>
</li>
<li><p><strong>iPad Orientation (iPad 화면 방향 지원)</strong></p>
<ul>
<li>☑ <strong>Portrait (세로 모드)</strong></li>
<li>☑ <strong>Upside Down (거꾸로 세로 모드)</strong></li>
<li>☑ <strong>Landscape Left (가로 모드 - 왼쪽)</strong></li>
<li>☑ <strong>Landscape Right (가로 모드 - 오른쪽)</strong>  </li>
</ul>
<p>→ iPad에서는 <strong>모든 방향(세로/거꾸로 세로/가로 모두) 지원</strong>  </p>
</li>
<li><p><strong>Status Bar Style (상태 바 스타일)</strong></p>
<ul>
<li><p><code>Default</code> (기본값 사용)<br />→ 상태 바(배터리, Wi-Fi 등 표시되는 부분)의 색상 스타일을 기본값으로 유지  </p>
</li>
<li><p>☐ <strong>Requires full screen</strong> (비활성화됨)<br />→ 체크하면 앱이 <strong>전체 화면 전용(멀티태스킹 불가)</strong>으로 실행됨<br />→ 현재 체크 해제되어 있어 <strong>멀티태스킹 가능</strong>  </p>
</li>
<li><p>☐ <strong>Supports multiple windows</strong> (비활성화됨)<br />→ 체크하면 iPad에서 <strong>멀티 윈도우(두 개 이상의 앱 창 실행) 가능</strong><br />→ 현재 체크 해제되어 있어 <strong>단일 창 모드만 지원</strong>  </p>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="📌-정리"><strong>📌 정리</strong></h3>
<ul>
<li>iOS 16 이상에서 실행 가능</li>
<li>앱 이름(Display Name) 미설정 (추후 설정 필요)</li>
<li>앱 식별자(Bundle ID): <code>kr.ac.induk.kyk.NightLight</code></li>
<li>세로(Portrait) 및 가로(Landscape) 모드 지원 (iPhone은 거꾸로 세로 미지원, iPad는 모든 방향 지원)</li>
<li>상태 바는 기본 스타일 유지</li>
<li>전체 화면 및 멀티 윈도우 기능은 사용하지 않음</li>
</ul>
<hr />
<h1 id="viewcontrollerswift">ViewController.swift</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/a5921027-7db1-4bca-ab63-54f94f85e25b/image.png" /></p>
<p>아래는 <code>ViewController.swift</code> 코드의 각 줄에 대한 상세한 설명입니다.</p>
<hr />
<pre><code class="language-swift">class ViewController: UIViewController {</code></pre>
<ul>
<li><strong><code>ViewController</code> 클래스 선언</strong><ul>
<li>이 클래스는 <code>UIViewController</code>를 상속받아 화면을 관리하는 역할을 합니다.</li>
<li>iOS 앱에서 <code>UIViewController</code>는 화면의 생명주기를 관리하는 기본 단위입니다.</li>
</ul>
</li>
</ul>
<hr />
<pre><code class="language-swift">    override func viewDidLoad() {
        super.viewDidLoad()
        print(&quot;viewDidLoad&quot;)
    }</code></pre>
<ul>
<li><strong><code>viewDidLoad()</code> 메서드</strong><ul>
<li><code>UIViewController</code> 생명주기 중에서 <strong>뷰가 메모리에 로드될 때 최초 한 번만 실행</strong>되는 메서드입니다.</li>
<li>보통 UI 초기화, 데이터 로드 등의 작업을 수행합니다.</li>
<li><code>super.viewDidLoad()</code>를 호출하여 상위 클래스(<code>UIViewController</code>)의 기본 동작을 유지합니다.</li>
<li><code>print(&quot;viewDidLoad&quot;)</code>를 실행하여 콘솔에 <code>&quot;viewDidLoad&quot;</code>라는 로그를 출력합니다.</li>
<li>이 메시지는 <strong>앱이 실행될 때 처음 한 번만 나타남</strong>.</li>
</ul>
</li>
</ul>
<hr />
<pre><code class="language-swift">    override func viewWillAppear(_ animated: Bool) {
        print(&quot;viewWillAppear&quot;)
    }</code></pre>
<ul>
<li><strong><code>viewWillAppear(_:)</code> 메서드</strong><ul>
<li>화면이 나타나기 <strong>직전</strong>에 호출됩니다.</li>
<li><code>animated</code> 매개변수:<ul>
<li><code>true</code>: 화면이 애니메이션과 함께 나타남</li>
<li><code>false</code>: 애니메이션 없이 즉시 표시됨</li>
</ul>
</li>
<li>주로 화면이 보이기 전에 데이터를 업데이트하거나 UI를 조정하는 데 사용됩니다.</li>
<li><code>print(&quot;viewWillAppear&quot;)</code>를 실행하여 <code>&quot;viewWillAppear&quot;</code> 로그를 출력합니다.</li>
<li><strong>잘못된 부분</strong>:  <ul>
<li><code>&quot;viewWillAppear&quot;</code>를 출력해야 하지만, <code>viewDidAppear(_:)</code> 메서드에서도 같은 문자열을 출력하고 있어 혼동을 일으킬 수 있습니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<pre><code class="language-swift">    override func viewDidAppear(_ animated: Bool) {
        print(&quot;viewWillAppear&quot;)
    }</code></pre>
<ul>
<li><strong><code>viewDidAppear(_:)</code> 메서드</strong><ul>
<li>화면이 <strong>완전히 나타난 후</strong> 호출됩니다.</li>
<li><code>animated</code> 매개변수의 의미는 <code>viewWillAppear(_:)</code>와 동일합니다.</li>
<li>화면이 나타난 후 실행해야 하는 작업(예: 애니메이션 시작, 네트워크 요청 실행 등)에 주로 사용됩니다.</li>
<li><strong>잘못된 부분</strong>:  <ul>
<li><code>print(&quot;viewWillAppear&quot;)</code>가 잘못 입력됨.  </li>
<li><strong>올바르게 수정하려면 <code>print(&quot;viewDidAppear&quot;)</code>로 변경해야 함.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="🔹-코드의-문제점-및-수정"><strong>🔹 코드의 문제점 및 수정</strong></h3>
<p><strong>문제:</strong>  </p>
<ul>
<li><code>viewDidAppear(_:)</code>에서 <code>&quot;viewWillAppear&quot;</code>을 출력하는 실수 발생</li>
<li><code>print(&quot;viewDidAppear&quot;)</code>로 수정해야 함</li>
</ul>
<p><strong>올바른 코드:</strong></p>
<pre><code class="language-swift">class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        print(&quot;viewDidLoad&quot;) // 화면이 처음 로드될 때 실행됨 (1회만 실행됨)
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated) // 부모 클래스의 기능 유지
        print(&quot;viewWillAppear&quot;) // 화면이 나타나기 직전에 실행됨 (매번 실행됨)
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated) // 부모 클래스의 기능 유지
        print(&quot;viewDidAppear&quot;) // 화면이 완전히 나타난 후 실행됨 (매번 실행됨)
    }
}</code></pre>
<h3 id="🔹-실행-흐름"><strong>🔹 실행 흐름</strong></h3>
<ol>
<li><code>viewDidLoad()</code> → 앱 실행 시 최초 1회 실행</li>
<li><code>viewWillAppear(_:)</code> → 화면이 나타날 때마다 실행</li>
<li><code>viewDidAppear(_:)</code> → 화면이 완전히 표시된 후 실행</li>
</ol>
<hr />
<h1 id="view-life-cycle">View Life Cycle</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/1c7d8aab-aa6a-43e3-9cf4-fa5392144083/image.png" /></p>
<h3 id="📌-view-life-cycle-설명-ios-uiviewcontroller-생명주기"><strong>📌 View Life Cycle 설명 (iOS UIViewController 생명주기)</strong></h3>
<p>위 이미지에서 iOS의 <strong>View Life Cycle(뷰 컨트롤러 생명 주기)</strong>에 대해 설명하고 있습니다.<br />iOS 앱의 화면(뷰)은 특정한 순서로 생성, 나타나고, 사라지는 과정을 거칩니다.<br />각 단계에서 특정 메서드가 호출되며, 이를 적절히 활용해야 합니다.</p>
<hr />
<h3 id="📌-view-life-cycle-단계별-설명"><strong>📌 View Life Cycle 단계별 설명</strong></h3>
<ol>
<li><p><strong><code>viewDidLoad()</code></strong></p>
<ul>
<li><strong>뷰 컨트롤러 객체가 생성될 때 최초 한 번 실행</strong>됨.</li>
<li>주로 <strong>초기화 작업 (데이터 로드, UI 설정 등)</strong> 에 사용.</li>
<li>화면이 나타날 때마다 실행되는 것이 아니라, <strong>한 번만 실행됨</strong>.</li>
</ul>
</li>
<li><p><strong><code>viewWillAppear(_:)</code></strong></p>
<ul>
<li><strong>뷰가 화면에 나타나기 직전에 실행됨</strong>.</li>
<li><strong>매번 실행됨</strong> (화면이 나타날 때마다 호출됨).</li>
<li>화면이 보이기 전에 준비해야 할 작업(데이터 갱신, UI 업데이트 등)에 사용.</li>
</ul>
</li>
<li><p><strong><code>viewDidAppear(_:)</code></strong></p>
<ul>
<li><strong>뷰가 화면에 완전히 나타난 후 실행됨</strong>.</li>
<li>네트워크 요청, 애니메이션 시작 등 <strong>뷰가 보인 후 실행되어야 하는 작업</strong>을 처리할 때 사용.</li>
<li>만약 <code>viewWillAppear(_:)</code>에서 작업하면 UI 업데이트가 완료되지 않아 화면 반영이 느릴 수 있음.</li>
</ul>
</li>
<li><p><strong><code>viewWillDisappear(_:)</code></strong></p>
<ul>
<li><strong>뷰가 사라지기 직전에 실행됨</strong>.</li>
<li>데이터 저장, 입력값 처리, 애니메이션 중지 등 필요한 작업 수행.</li>
</ul>
</li>
<li><p><strong><code>viewDidDisappear(_:)</code></strong></p>
<ul>
<li><strong>뷰가 화면에서 완전히 사라진 후 실행됨</strong>.</li>
<li>백그라운드 작업을 중지하거나 리소스를 해제할 때 사용.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="📌-view-life-cycle의-흐름"><strong>📌 View Life Cycle의 흐름</strong></h3>
<ol>
<li><code>viewDidLoad()</code> → <strong>최초 1회 실행</strong> (앱 실행 시)</li>
<li><code>viewWillAppear(_:)</code> → <strong>화면이 보이기 직전 실행</strong> (매번 실행)</li>
<li><code>viewDidAppear(_:)</code> → <strong>화면이 완전히 나타난 후 실행</strong> (매번 실행)</li>
<li><code>viewWillDisappear(_:)</code> → <strong>화면이 사라지기 직전 실행</strong></li>
<li><code>viewDidDisappear(_:)</code> → <strong>화면이 완전히 사라진 후 실행</strong></li>
</ol>
<hr />
<h3 id="📌-활용-예시"><strong>📌 활용 예시</strong></h3>
<ul>
<li><strong><code>viewDidLoad()</code></strong>: 네트워크 데이터 요청, UI 기본 설정</li>
<li><strong><code>viewWillAppear(_:)</code></strong>: 사용자 설정 반영, UI 갱신</li>
<li><strong><code>viewDidAppear(_:)</code></strong>: 애니메이션 시작, 네트워크 작업</li>
<li><strong><code>viewWillDisappear(_:)</code></strong>: 데이터 저장, 키보드 닫기</li>
<li><strong><code>viewDidDisappear(_:)</code></strong>: 리소스 해제, 타이머 중지</li>
</ul>
<p>이 개념을 이해하면 <strong>iOS 화면 전환 시 최적의 위치에서 코드를 실행</strong>할 수 있습니다! 🚀</p>
<hr />
<h1 id="appdelegateswift">Appdelegate.swift</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/e9042ec8-0c2c-4848-b70e-9cbb7f222c72/image.png" /></p>
<h3 id="📌-appdelegateswift-상세-설명"><strong>📌 <code>AppDelegate.swift</code> 상세 설명</strong></h3>
<p><code>AppDelegate.swift</code>는 iOS 앱의 <strong>시작과 종료, 전체적인 라이프사이클을 관리하는 파일</strong>입니다.<br />이 파일은 앱이 실행될 때 시스템과 상호작용하는 중요한 역할을 합니다.</p>
<hr />
<h2 id="🔹-코드-상세-분석"><strong>🔹 코드 상세 분석</strong></h2>
<pre><code class="language-swift">//
//  AppDelegate.swift
//  NightLight
//
//  Created by CMAC_43 on 2025/03/19.
//</code></pre>
<ul>
<li><strong>파일 헤더 주석</strong>  <ul>
<li>Swift 파일의 기본적인 정보(파일명, 프로젝트명, 생성자, 생성일)가 포함되어 있음.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="📌-import-uikit"><strong>📌 <code>import UIKit</code></strong></h3>
<pre><code class="language-swift">import UIKit</code></pre>
<ul>
<li><strong>UIKit 프레임워크를 가져옴</strong><ul>
<li>iOS 앱의 UI를 관리하는 기본 프레임워크.</li>
<li>앱의 화면 표시, 이벤트 처리 등을 담당.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="📌-main-키워드"><strong>📌 <code>@main</code> 키워드</strong></h3>
<pre><code class="language-swift">@main
class AppDelegate: UIResponder, UIApplicationDelegate {</code></pre>
<ul>
<li><p><code>@main</code>  </p>
<ul>
<li>이 클래스가 앱의 <strong>시작 지점(entry point)</strong> 임을 나타냄.  </li>
<li><code>UIApplicationMain</code>의 역할을 수행하며 앱이 실행될 때 <code>AppDelegate</code>가 초기화됨.  </li>
</ul>
</li>
<li><p><code>UIResponder</code>  </p>
<ul>
<li><strong>이벤트 처리(터치, 모션 등)를 받을 수 있는 객체</strong>라는 의미.  </li>
<li><code>AppDelegate</code>가 <code>UIApplicationDelegate</code>를 따르고 있으므로 앱 전반적인 이벤트를 처리할 수 있음.</li>
</ul>
</li>
<li><p><code>UIApplicationDelegate</code>  </p>
<ul>
<li><strong>앱의 실행 상태를 관리하는 프로토콜</strong>.  </li>
<li>앱이 시작, 백그라운드 전환, 종료될 때 호출되는 메서드를 포함.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="🔹-application_didfinishlaunchingwithoptions"><strong>🔹 <code>application(_:didFinishLaunchingWithOptions:)</code></strong></h2>
<pre><code class="language-swift">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    // 앱 실행 후 사용자 정의 설정을 적용하는 지점
    return true
}</code></pre>
<h3 id="📌-설명"><strong>📌 설명</strong></h3>
<ul>
<li><strong>앱이 실행된 직후 한 번만 호출됨.</strong></li>
<li><strong>앱의 초기 설정을 수행하는 메서드</strong>로, 보통 아래와 같은 작업을 함:<ul>
<li>Firebase, Google Analytics, Push 알림 설정</li>
<li>기본 데이터 로딩</li>
<li>로그 시스템 설정</li>
</ul>
</li>
<li><code>return true</code> → 정상적으로 실행되었음을 의미.  </li>
</ul>
<hr />
<h2 id="🔹-application_configurationforconnectingoptions"><strong>🔹 <code>application(_:configurationForConnecting:options:)</code></strong></h2>
<pre><code class="language-swift">func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -&gt; UISceneConfiguration {
    // 새로운 씬을 생성할 때 사용할 설정을 선택하는 메서드
    return UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role)
}</code></pre>
<h3 id="📌-설명-1"><strong>📌 설명</strong></h3>
<ul>
<li>iOS 13부터 <strong>멀티 윈도우(SceneDelegate 기반)</strong> 를 지원하면서 추가됨.</li>
<li><strong>새로운 씬(scene)이 생성될 때 호출됨.</strong><ul>
<li>예를 들어, iPad에서 앱을 멀티 윈도우로 실행할 경우 새로운 Scene이 만들어짐.</li>
</ul>
</li>
<li><code>UISceneConfiguration(name: &quot;Default Configuration&quot;, sessionRole: connectingSceneSession.role)</code><ul>
<li>기본 설정(<code>Default Configuration</code>)을 적용하여 새로운 Scene을 생성.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="🔹-application_diddiscardscenesessions"><strong>🔹 <code>application(_:didDiscardSceneSessions:)</code></strong></h2>
<pre><code class="language-swift">func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;) {
    // 사용자가 씬 세션을 삭제할 경우 호출됨.
    // 앱이 실행되지 않은 상태에서 씬 세션이 삭제된 경우, 
    // application:didFinishLaunchingWithOptions 이후에 이 함수가 호출됨.
    // 삭제된 씬과 관련된 리소스를 정리하는 데 사용할 수 있음.
}</code></pre>
<h3 id="📌-설명-2"><strong>📌 설명</strong></h3>
<ul>
<li><strong>사용자가 실행 중이던 Scene을 닫았을 때 호출됨.</strong></li>
<li>예를 들어:<ul>
<li>iPad에서 <strong>멀티 윈도우 기능을 통해 앱을 여러 개 열었다가 일부를 닫을 때</strong> 실행됨.</li>
<li>백그라운드에서 실행 중이던 <strong>앱의 특정 Scene이 시스템에 의해 종료될 때</strong> 실행됨.</li>
</ul>
</li>
<li><strong>용도:</strong>  <ul>
<li>불필요한 <strong>리소스 정리, 데이터 저장, 상태 복구 작업</strong>을 수행하는 데 사용.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="📌-appdelegateswift의-전체적인-역할"><strong>📌 <code>AppDelegate.swift</code>의 전체적인 역할</strong></h3>
<ol>
<li><strong>앱이 실행되면 초기화 작업(<code>didFinishLaunchingWithOptions</code>) 수행</strong></li>
<li><strong>새로운 화면(Scene)이 생성될 때(<code>configurationForConnecting</code>) 설정</strong></li>
<li><strong>앱의 특정 화면이 닫힐 때(<code>didDiscardSceneSessions</code>) 정리 작업 수행</strong></li>
<li><strong>앱이 UI 이벤트를 받을 수 있도록 <code>UIResponder</code>를 상속받음</strong></li>
</ol>
<hr />
<h2 id="🔹-추가적으로-구현할-수-있는-메서드"><strong>🔹 추가적으로 구현할 수 있는 메서드</strong></h2>
<p><code>AppDelegate</code>에는 <strong>앱의 상태 변화(백그라운드, 포그라운드 등)에 따라 동작하는 메서드</strong>가 있음.</p>
<h3 id="📌-앱이-백그라운드로-전환될-때"><strong>📌 앱이 백그라운드로 전환될 때</strong></h3>
<pre><code class="language-swift">func applicationDidEnterBackground(_ application: UIApplication) {
    print(&quot;앱이 백그라운드로 이동했습니다.&quot;)
    // 데이터 저장, 네트워크 요청 중지 등 필요한 작업 수행
}</code></pre>
<h3 id="📌-앱이-다시-활성화될-때"><strong>📌 앱이 다시 활성화될 때</strong></h3>
<pre><code class="language-swift">func applicationWillEnterForeground(_ application: UIApplication) {
    print(&quot;앱이 다시 활성화되었습니다.&quot;)
    // 화면 UI 업데이트, 네트워크 연결 복구 등 수행
}</code></pre>
<hr />
<h2 id="📌-요약"><strong>📌 요약</strong></h2>
<table>
<thead>
<tr>
<th>메서드</th>
<th>호출 시점</th>
<th>주요 역할</th>
</tr>
</thead>
<tbody><tr>
<td><code>application(_:didFinishLaunchingWithOptions:)</code></td>
<td>앱이 시작될 때</td>
<td>초기 설정, 데이터 로드</td>
</tr>
<tr>
<td><code>application(_:configurationForConnecting:options:)</code></td>
<td>새 Scene 생성 시</td>
<td>Scene 생성 시 필요한 설정 적용</td>
</tr>
<tr>
<td><code>application(_:didDiscardSceneSessions:)</code></td>
<td>Scene이 닫힐 때</td>
<td>리소스 해제, 데이터 저장</td>
</tr>
<tr>
<td><code>applicationDidEnterBackground(_:)</code></td>
<td>앱이 백그라운드로 갈 때</td>
<td>네트워크 중지, 데이터 저장</td>
</tr>
<tr>
<td><code>applicationWillEnterForeground(_:)</code></td>
<td>앱이 다시 활성화될 때</td>
<td>UI 업데이트, 데이터 복구</td>
</tr>
</tbody></table>
<hr />
<h3 id="📌-결론"><strong>📌 결론</strong></h3>
<p><code>AppDelegate.swift</code>는 앱의 <strong>실행, 종료, 백그라운드 전환 등의 중요한 이벤트를 관리하는 핵심 클래스</strong>입니다.<br />여기에 추가적인 로직을 작성하면 앱의 상태 변화에 따라 적절한 작업을 수행할 수 있습니다.</p>
<hr />
<h1 id="📌-scenedelegateswift-상세-설명"><strong>📌 <code>SceneDelegate.swift</code> 상세 설명</strong></h1>
<p>iOS 13부터 <strong>멀티 윈도우(scene-based life cycle)</strong> 기능이 도입되면서 <code>AppDelegate.swift</code>에서 일부 기능이 <strong>SceneDelegate</strong>로 이동되었습니다.<br />이 파일은 <strong>앱의 개별 화면(Scene)의 생명주기를 관리</strong>합니다.</p>
<hr />
<h2 id="📌-코드-분석"><strong>📌 코드 분석</strong></h2>
<pre><code class="language-swift">//
//  SceneDelegate.swift
//  NightLight
//
//  Created by CMAC_43 on 2025/03/19.
//</code></pre>
<ul>
<li><strong>파일 헤더 주석</strong>  <ul>
<li>파일명, 프로젝트명, 생성자, 생성일이 포함되어 있음.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="📌-import-uikit-1"><strong>📌 <code>import UIKit</code></strong></h3>
<pre><code class="language-swift">import UIKit</code></pre>
<ul>
<li>UIKit 프레임워크는 <strong>iOS UI를 관리하는 기본적인 프레임워크</strong>.</li>
<li><code>UIWindow</code>, <code>UIViewController</code> 등의 UI 요소를 관리.</li>
</ul>
<hr />
<h3 id="📌-scenedelegate-클래스-정의"><strong>📌 <code>SceneDelegate</code> 클래스 정의</strong></h3>
<pre><code class="language-swift">class SceneDelegate: UIResponder, UIWindowSceneDelegate {</code></pre>
<ul>
<li><code>SceneDelegate</code>는 <code>UIResponder</code>를 상속받고, <code>UIWindowSceneDelegate</code> 프로토콜을 따름.</li>
<li><code>UIWindowSceneDelegate</code>:<ul>
<li>앱의 개별 <strong>Scene</strong>(화면)을 관리하는 프로토콜.</li>
<li>iPad에서 <strong>멀티 윈도우 기능</strong>을 사용할 때 각 창(Scene)을 제어하는 역할.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="📌-window-속성"><strong>📌 <code>window</code> 속성</strong></h3>
<pre><code class="language-swift">var window: UIWindow?</code></pre>
<ul>
<li>앱의 <strong>메인 윈도우(UI 화면을 표시하는 객체)</strong>.</li>
<li><code>SceneDelegate</code>는 <code>window</code>를 관리하며, 사용자의 화면을 표시하는 역할.</li>
</ul>
<hr />
<h2 id="🔹-생명주기lifecycle-메서드"><strong>🔹 생명주기(Lifecycle) 메서드</strong></h2>
<h3 id="1️⃣-scene_willconnecttooptions"><strong>1️⃣ <code>scene(_:willConnectTo:options:)</code></strong></h3>
<pre><code class="language-swift">func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
    // UIWindowScene 타입인지 확인 후 설정
    guard let _ = (scene as? UIWindowScene) else { return }
}</code></pre>
<ul>
<li><strong>Scene이 생성될 때 호출됨.</strong></li>
<li>보통 앱의 초기화 작업(예: <code>window</code> 설정, 루트 뷰 컨트롤러 설정)을 수행함.</li>
<li><strong>Storyboard를 사용하는 경우</strong> 자동으로 <code>window</code>가 설정되므로 따로 코드를 작성할 필요 없음.</li>
<li><code>guard let _ = (scene as? UIWindowScene) else { return }</code><ul>
<li><code>scene</code>이 <code>UIWindowScene</code> 타입인지 확인.</li>
<li>그렇지 않으면 함수 종료.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="2️⃣-scenediddisconnect_"><strong>2️⃣ <code>sceneDidDisconnect(_:)</code></strong></h3>
<pre><code class="language-swift">func sceneDidDisconnect(_ scene: UIScene) {
    // Scene이 시스템에 의해 해제될 때 호출됨.
}</code></pre>
<ul>
<li>Scene이 <strong>삭제되거나 해제될 때</strong> 호출됨.</li>
<li>Scene이 사라졌지만, 앱이 실행 중이면 다시 생성될 수도 있음.</li>
<li>예: iPad에서 멀티태스킹으로 앱 창을 닫을 때 호출됨.</li>
<li><strong>리소스를 정리하거나 저장할 데이터가 있다면 여기서 처리</strong>.</li>
</ul>
<hr />
<h3 id="3️⃣-scenedidbecomeactive_"><strong>3️⃣ <code>sceneDidBecomeActive(_:)</code></strong></h3>
<pre><code class="language-swift">func sceneDidBecomeActive(_ scene: UIScene) {
    // Scene이 활성화될 때 호출됨.
}</code></pre>
<ul>
<li><strong>Scene이 활성화될 때 호출됨.</strong></li>
<li>예: 앱이 실행되거나, 백그라운드에서 복귀할 때.</li>
<li>보통 <strong>일시 정지된 작업(타이머, 애니메이션, 네트워크 요청)을 다시 시작</strong>하는 데 사용됨.</li>
</ul>
<hr />
<h3 id="4️⃣-scenewillresignactive_"><strong>4️⃣ <code>sceneWillResignActive(_:)</code></strong></h3>
<pre><code class="language-swift">func sceneWillResignActive(_ scene: UIScene) {
    // Scene이 비활성화될 때 호출됨.
}</code></pre>
<ul>
<li>Scene이 <strong>비활성화되기 직전에 호출됨.</strong></li>
<li>전화가 오거나, 화면이 잠길 때 발생.</li>
<li><strong>일시적으로 멈춰야 하는 작업(음악, 타이머, 네트워크 요청 등)을 중단</strong>.</li>
</ul>
<hr />
<h3 id="5️⃣-scenewillenterforeground_"><strong>5️⃣ <code>sceneWillEnterForeground(_:)</code></strong></h3>
<pre><code class="language-swift">func sceneWillEnterForeground(_ scene: UIScene) {
    // Scene이 백그라운드에서 포그라운드로 전환될 때 호출됨.
}</code></pre>
<ul>
<li>앱이 <strong>백그라운드에서 다시 활성화될 때 호출됨.</strong></li>
<li>주로 UI 업데이트, 데이터 동기화 등에 사용.</li>
</ul>
<hr />
<h3 id="6️⃣-scenedidenterbackground_"><strong>6️⃣ <code>sceneDidEnterBackground(_:)</code></strong></h3>
<pre><code class="language-swift">func sceneDidEnterBackground(_ scene: UIScene) {
    // Scene이 백그라운드로 전환될 때 호출됨.
}</code></pre>
<ul>
<li><strong>Scene이 백그라운드로 전환될 때 호출됨.</strong></li>
<li>앱이 완전히 종료되는 것은 아니지만, <strong>백그라운드 상태로 들어감</strong>.</li>
<li><strong>여기서 데이터를 저장하거나, 네트워크 연결을 해제하는 것이 중요</strong>.</li>
<li>예제:<pre><code class="language-swift">func sceneDidEnterBackground(_ scene: UIScene) {
    print(&quot;앱이 백그라운드로 전환됨. 데이터 저장 중...&quot;)
    saveUserData()
}</code></pre>
</li>
<li><strong><code>sceneDidDisconnect(_:)</code>와 차이점</strong><ul>
<li><code>sceneDidDisconnect</code> → Scene이 완전히 삭제될 때 호출.</li>
<li><code>sceneDidEnterBackground</code> → 단순히 백그라운드로 전환될 때 호출.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="📌-scenedelegate-vs-appdelegate"><strong>📌 SceneDelegate vs AppDelegate</strong></h2>
<table>
<thead>
<tr>
<th>비교 항목</th>
<th>AppDelegate</th>
<th>SceneDelegate</th>
</tr>
</thead>
<tbody><tr>
<td>관리 범위</td>
<td>앱 전체</td>
<td>개별 Scene(화면)</td>
</tr>
<tr>
<td><code>application(_:didFinishLaunchingWithOptions:)</code></td>
<td>앱 시작 시 1회 실행</td>
<td>X</td>
</tr>
<tr>
<td><code>applicationDidEnterBackground(_:)</code></td>
<td>앱이 백그라운드로 갈 때 실행</td>
<td><code>sceneDidEnterBackground(_:)</code> 로 대체됨</td>
</tr>
<tr>
<td>멀티 윈도우 지원</td>
<td>X</td>
<td>O (iPad 멀티태스킹 가능)</td>
</tr>
</tbody></table>
<hr />
<h2 id="📌-정리-1"><strong>📌 정리</strong></h2>
<ol>
<li><code>SceneDelegate.swift</code>는 <strong>앱의 개별 Scene(화면)의 생명주기를 관리</strong>하는 역할을 함.</li>
<li>iOS 13 이상부터 <strong>멀티 윈도우 지원</strong>을 위해 도입됨.</li>
<li>주요 메서드:<ul>
<li><code>scene(_:willConnectTo:)</code> → Scene이 생성될 때.</li>
<li><code>sceneDidBecomeActive(_:)</code> → Scene이 활성화될 때.</li>
<li><code>sceneWillResignActive(_:)</code> → Scene이 비활성화되기 직전.</li>
<li><code>sceneDidEnterBackground(_:)</code> → Scene이 백그라운드로 갈 때.</li>
<li><code>sceneDidDisconnect(_:)</code> → Scene이 완전히 종료될 때.</li>
</ul>
</li>
<li><strong>멀티태스킹(iPad) 환경에서 중요한 역할</strong>을 함.</li>
</ol>
<p>이제 <code>SceneDelegate.swift</code>의 역할을 확실하게 이해할 수 있을 것입니다! 🚀</p>
<hr />
<h1 id="app-life-cycle">App Life Cycle</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/475a0ba9-e9da-4de7-8142-d7e5b7160933/image.png" /></p>
<h3 id="📌-app-life-cycle-앱-생명주기-설명"><strong>📌 App Life Cycle (앱 생명주기) 설명</strong></h3>
<p>iOS 앱은 <strong>실행 모드와 상태</strong>를 가지며, 특정 이벤트(앱 실행, 백그라운드 이동 등)에 따라 상태가 변화합니다.<br />이러한 상태 변화를 고려하여 <strong>적절한 로직을 구현해야</strong> 합니다.</p>
<hr />
<h2 id="🔹-주요-상태"><strong>🔹 주요 상태</strong></h2>
<h3 id="1️⃣-not-running-비실행-상태"><strong>1️⃣ Not Running (비실행 상태)</strong></h3>
<ul>
<li>앱이 <strong>아직 실행되지 않았거나</strong>, 실행되었다가 시스템에 의해 종료된 상태.</li>
<li>사용자가 앱을 처음 실행하거나, 앱이 강제 종료되었을 때 해당됨.</li>
</ul>
<hr />
<h2 id="2️⃣-foreground-mode-포그라운드-모드"><strong>2️⃣ Foreground Mode (포그라운드 모드)</strong></h2>
<ul>
<li>앱이 <strong>사용자에게 보이는 상태</strong>이며, 실행 중인 상태.</li>
</ul>
<h3 id="✅-active-활성"><strong>✅ Active (활성)</strong></h3>
<ul>
<li>앱이 <strong>완전히 실행 중</strong>이고, <strong>이벤트를 받을 수 있는 상태</strong>.</li>
<li>사용자가 앱과 <strong>상호작용할 수 있음</strong> (예: 화면 터치, 버튼 클릭).</li>
</ul>
<h3 id="✅-inactive-비활성"><strong>✅ Inactive (비활성)</strong></h3>
<ul>
<li>앱이 화면에 표시되어 있지만, <strong>사용자의 입력을 받을 수 없는 상태</strong>.</li>
<li>전화 수신, 화면 전환 등의 이유로 <strong>일시적으로 중단</strong>되는 경우 발생.</li>
</ul>
<hr />
<h2 id="3️⃣-background-mode-백그라운드-모드"><strong>3️⃣ Background Mode (백그라운드 모드)</strong></h2>
<ul>
<li>앱이 <strong>백그라운드에 있지만, 실행 중인 상태</strong>.</li>
<li>화면에는 보이지 않지만, 특정 코드(예: 음악 재생, 파일 다운로드 등)를 수행할 수 있음.</li>
</ul>
<h3 id="✅-running-백그라운드-실행"><strong>✅ Running (백그라운드 실행)</strong></h3>
<ul>
<li>백그라운드에서도 <strong>작업을 계속 수행하는 상태</strong>.</li>
<li>네트워크 요청, 위치 정보 추적, 음악 재생 등의 작업이 가능.</li>
</ul>
<h3 id="✅-suspended-중단됨"><strong>✅ Suspended (중단됨)</strong></h3>
<ul>
<li>앱이 백그라운드에 있지만, <strong>코드를 실행하지 않고 멈춰있는 상태</strong>.</li>
<li>시스템이 필요할 경우 <strong>앱을 강제 종료할 수도 있음</strong>.</li>
<li><strong>배터리 절약을 위해 백그라운드 실행이 필요하지 않다면 자동으로 이 상태로 전환됨.</strong></li>
</ul>
<hr />
<h2 id="🔹-상태-전환-흐름"><strong>🔹 상태 전환 흐름</strong></h2>
<h3 id="1️⃣-not-running-→-active"><strong>1️⃣ Not Running → Active</strong></h3>
<ul>
<li>앱을 처음 실행할 때.</li>
</ul>
<h3 id="2️⃣-active-→-inactive-→-running"><strong>2️⃣ Active → Inactive → Running</strong></h3>
<ul>
<li>앱을 백그라운드로 보냈을 때.</li>
<li>예: 홈 버튼을 눌러 앱을 숨기거나, 다른 앱으로 전환할 때.</li>
</ul>
<h3 id="3️⃣-active-→-inactive-→-suspended"><strong>3️⃣ Active → Inactive → Suspended</strong></h3>
<ul>
<li>백그라운드에서 일정 시간이 지나면 시스템이 앱을 <strong>Suspended 상태로 전환</strong>.</li>
</ul>
<h3 id="4️⃣-running-→-active"><strong>4️⃣ Running → Active</strong></h3>
<ul>
<li>백그라운드에서 앱을 다시 실행할 때.</li>
</ul>
<hr />
<h2 id="📌-ios-앱-생명주기와-이벤트-연결"><strong>📌 iOS 앱 생명주기와 이벤트 연결</strong></h2>
<table>
<thead>
<tr>
<th>상태</th>
<th>메서드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>Not Running</code> → <code>Foreground Active</code></td>
<td><code>application(_:didFinishLaunchingWithOptions:)</code></td>
<td>앱이 실행될 때 호출됨</td>
</tr>
<tr>
<td><code>Foreground Active</code> → <code>Background</code></td>
<td><code>applicationDidEnterBackground(_:)</code></td>
<td>앱이 백그라운드로 이동할 때 호출됨</td>
</tr>
<tr>
<td><code>Background</code> → <code>Foreground Active</code></td>
<td><code>applicationWillEnterForeground(_:)</code></td>
<td>앱이 백그라운드에서 포그라운드로 복귀할 때 호출됨</td>
</tr>
<tr>
<td><code>Foreground Active</code> → <code>Inactive</code></td>
<td><code>applicationWillResignActive(_:)</code></td>
<td>전화가 오거나, 홈 버튼을 눌렀을 때 호출됨</td>
</tr>
<tr>
<td><code>Inactive</code> → <code>Foreground Active</code></td>
<td><code>applicationDidBecomeActive(_:)</code></td>
<td>앱이 다시 활성화될 때 호출됨</td>
</tr>
<tr>
<td><code>Background</code> → <code>Not Running</code></td>
<td><code>applicationWillTerminate(_:)</code></td>
<td>앱이 완전히 종료될 때 호출됨</td>
</tr>
</tbody></table>
<hr />
<h2 id="📌-앱-생명주기와-코드-활용-예시"><strong>📌 앱 생명주기와 코드 활용 예시</strong></h2>
<h3 id="✅-앱이-실행될-때-데이터-로드"><strong>✅ 앱이 실행될 때 데이터 로드</strong></h3>
<pre><code class="language-swift">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
    loadUserData()
    return true
}</code></pre>
<h3 id="✅-백그라운드로-전환될-때-데이터-저장"><strong>✅ 백그라운드로 전환될 때 데이터 저장</strong></h3>
<pre><code class="language-swift">func applicationDidEnterBackground(_ application: UIApplication) {
    saveUserData()
}</code></pre>
<h3 id="✅-포그라운드로-복귀할-때-ui-업데이트"><strong>✅ 포그라운드로 복귀할 때 UI 업데이트</strong></h3>
<pre><code class="language-swift">func applicationWillEnterForeground(_ application: UIApplication) {
    refreshUI()
}</code></pre>
<hr />
<h2 id="📌-정리-2"><strong>📌 정리</strong></h2>
<ol>
<li><strong>앱은 실행 상태에 따라 Not Running / Foreground / Background 모드를 가짐.</strong></li>
<li><strong>Foreground Mode</strong><ul>
<li><strong>Active</strong>: 실행 중, 사용자의 입력을 받을 수 있음.</li>
<li><strong>Inactive</strong>: 일시적으로 중단된 상태 (예: 전화 수신).</li>
</ul>
</li>
<li><strong>Background Mode</strong><ul>
<li><strong>Running</strong>: 백그라운드에서도 실행됨 (예: 음악 재생).</li>
<li><strong>Suspended</strong>: 코드 실행이 중단된 상태, 필요 시 시스템이 종료할 수도 있음.</li>
</ul>
</li>
<li><strong>적절한 생명주기 이벤트를 활용하여 앱의 데이터를 저장하고, UI를 업데이트해야 함.</strong></li>
</ol>
<p>위 내용을 이해하면 <strong>iOS 앱의 동작 방식과 최적의 코드 작성 방법</strong>을 알 수 있습니다! 🚀</p>
<hr />
<h1 id="📌-uiview-개요-ios-view"><strong>📌 UIView 개요 (iOS View)</strong></h1>
<p><code>UIView</code>는 <strong>iOS UI(User Interface)의 기본 구성 요소</strong>로, 모든 화면 요소(버튼, 이미지, 레이블 등)의 기본 클래스입니다.</p>
<hr />
<h2 id="🔹-uiview의-특징"><strong>🔹 UIView의 특징</strong></h2>
<ol>
<li><p><strong>UIKit 프레임워크의 핵심 요소</strong>  </p>
<ul>
<li><code>UIView</code>는 <strong>UIKit의 기본 클래스</strong>이며, 모든 UI 요소의 부모 클래스.</li>
<li>모든 뷰는 <strong>UIView의 자식 클래스</strong>.</li>
</ul>
</li>
<li><p><strong>뷰는 UI를 구성하는 역할</strong></p>
<ul>
<li>화면에서 사용자의 <strong>터치 이벤트</strong>를 처리.</li>
<li>뷰의 <strong>내용을 그리는 방법</strong>을 제공.</li>
<li>애니메이션 및 트랜지션 효과를 적용 가능.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="🔹-uiview-계층-구조-view-hierarchy"><strong>🔹 UIView 계층 구조 (View Hierarchy)</strong></h2>
<ul>
<li>하나의 <strong>뷰(View)는 여러 개의 하위 뷰(Subview)를 포함할 수 있음</strong>.</li>
<li>뷰 계층 구조(View Hierarchy)를 통해 <strong>뷰 간의 위치 관계와 그리기 순서</strong>를 결정.</li>
</ul>
<h3 id="✅-뷰-계층-구조-예시"><strong>✅ 뷰 계층 구조 예시</strong></h3>
<pre><code class="language-swift">let parentView = UIView(frame: CGRect(x: 50, y: 50, width: 200, height: 200))
parentView.backgroundColor = .blue

let childView = UIView(frame: CGRect(x: 20, y: 20, width: 100, height: 100))
childView.backgroundColor = .red

// 부모 뷰에 자식 뷰 추가
parentView.addSubview(childView)</code></pre>
<ul>
<li><code>parentView</code>(부모 뷰) 안에 <code>childView</code>(하위 뷰)가 포함됨.</li>
<li>하위 뷰는 <strong>부모 뷰의 영역 내에서만 그려짐</strong>.</li>
</ul>
<hr />
<h2 id="🔹-uiview의-주요-자식-클래스"><strong>🔹 UIView의 주요 자식 클래스</strong></h2>
<table>
<thead>
<tr>
<th>클래스</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>UILabel</code></td>
<td>텍스트를 표시하는 뷰</td>
</tr>
<tr>
<td><code>UIImageView</code></td>
<td>이미지를 표시하는 뷰</td>
</tr>
<tr>
<td><code>UIButton</code></td>
<td>버튼 (사용자 입력을 받음)</td>
</tr>
<tr>
<td><code>UITextField</code></td>
<td>텍스트 입력 필드</td>
</tr>
<tr>
<td><code>UIScrollView</code></td>
<td>스크롤이 가능한 컨테이너 뷰</td>
</tr>
<tr>
<td><code>UITableView</code></td>
<td>리스트 형태의 UI 구성</td>
</tr>
<tr>
<td><code>UICollectionView</code></td>
<td>그리드 형태의 UI 구성</td>
</tr>
</tbody></table>
<hr />
<h2 id="🔹-uiview의-주요-메서드"><strong>🔹 UIView의 주요 메서드</strong></h2>
<h3 id="✅-뷰-추가-및-제거"><strong>✅ 뷰 추가 및 제거</strong></h3>
<pre><code class="language-swift">parentView.addSubview(childView) // 하위 뷰 추가
childView.removeFromSuperview()  // 하위 뷰 제거</code></pre>
<ul>
<li><code>addSubview(_:)</code>: 뷰를 부모 뷰에 추가.</li>
<li><code>removeFromSuperview()</code>: 부모 뷰에서 제거.</li>
</ul>
<h3 id="✅-뷰-위치-및-크기-설정"><strong>✅ 뷰 위치 및 크기 설정</strong></h3>
<pre><code class="language-swift">childView.frame = CGRect(x: 30, y: 30, width: 150, height: 150)</code></pre>
<ul>
<li><code>frame</code>: <strong>뷰의 위치와 크기</strong>를 설정.</li>
</ul>
<h3 id="✅-뷰의-투명도-및-가시성-조절"><strong>✅ 뷰의 투명도 및 가시성 조절</strong></h3>
<pre><code class="language-swift">childView.alpha = 0.5   // 반투명 설정
childView.isHidden = true // 뷰 숨기기</code></pre>
<ul>
<li><code>alpha</code>: 0(완전 투명) ~ 1(완전 불투명).</li>
<li><code>isHidden</code>: <code>true</code>이면 뷰가 화면에서 사라짐.</li>
</ul>
<hr />
<h2 id="📌-정리-3"><strong>📌 정리</strong></h2>
<ol>
<li><code>UIView</code>는 <strong>모든 UI 요소의 기본 클래스</strong>.</li>
<li><strong>뷰 계층 구조(View Hierarchy)</strong>를 통해 뷰 간의 관계를 설정.</li>
<li><code>UILabel</code>, <code>UIButton</code>, <code>UIImageView</code> 등은 <code>UIView</code>의 <strong>자식 클래스</strong>.</li>
<li><code>addSubview()</code>, <code>removeFromSuperview()</code>, <code>frame</code> 등을 사용하여 뷰를 동적으로 조작 가능.</li>
</ol>
<p>UIView의 개념을 이해하면 <strong>iOS UI 개발의 기초를 다질 수 있습니다!</strong> 🚀</p>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/76c5aead-1ef2-4d1e-8ff4-aa0246ce32b3/image.png" /></p>
<hr />
<h1 id="📌-uiwindow-클래스-개요-ios-앱의-최상위-ui-컨테이너"><strong>📌 UIWindow 클래스 개요 (iOS 앱의 최상위 UI 컨테이너)</strong></h1>
<p><code>UIWindow</code>는 iOS 앱의 <strong>UI를 표시하는 기본적인 컨테이너</strong>로, <strong>모든 뷰(View)와 뷰 컨트롤러(ViewController)를 포함하는 최상위 요소</strong>입니다.<br />즉, <strong>앱 화면을 그리는 배경이자, 이벤트를 분배하는 핵심 역할을 수행</strong>합니다.</p>
<hr />
<h2 id="🔹-uiwindow의-특징"><strong>🔹 UIWindow의 특징</strong></h2>
<ol>
<li><code>UIWindow</code>는 <strong><code>UIView</code>를 상속</strong>받음.</li>
<li><strong>앱의 UI를 그리는 가장 상위 컨테이너</strong> 역할.</li>
<li><strong>각 Scene마다 독립적인 UIWindow 인스턴스를 가질 수 있음</strong> (iOS 13+ 멀티 윈도우 지원).</li>
<li>앱의 <strong>루트 뷰 컨트롤러(Root View Controller)를 포함</strong>하며, 화면의 내비게이션을 담당.</li>
</ol>
<hr />
<h2 id="🔹-uiwindow의-역할"><strong>🔹 UIWindow의 역할</strong></h2>
<ol>
<li><strong>뷰 컨트롤러 및 그 하위 뷰들을 포함하고, 화면에 렌더링</strong>  <ul>
<li>앱의 모든 화면 요소(버튼, 레이블 등)는 <code>UIWindow</code> 내에서 동작함.</li>
</ul>
</li>
<li><strong>사용자의 입력 이벤트를 받아서 적절한 뷰나 컨트롤러로 전달</strong>  <ul>
<li>터치, 스크롤 등의 이벤트를 적절한 <code>UIView</code> 또는 <code>UIViewController</code>로 분배.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="🔹-uiwindow-생성-및-설정-방법"><strong>🔹 UIWindow 생성 및 설정 방법</strong></h2>
<p>앱이 실행될 때 <code>UIWindow</code>가 자동으로 생성되지만, 코드로 직접 설정할 수도 있습니다.</p>
<h3 id="✅-uiwindow-수동-생성-예제"><strong>✅ UIWindow 수동 생성 예제</strong></h3>
<pre><code class="language-swift">import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {

        // Scene이 UIWindowScene인지 확인
        guard let windowScene = (scene as? UIWindowScene) else { return }

        // UIWindow 생성 및 화면 크기 설정
        window = UIWindow(windowScene: windowScene)
        window?.frame = UIScreen.main.bounds

        // Root View Controller 설정
        let rootVC = ViewController()
        window?.rootViewController = rootVC

        // UIWindow 표시
        window?.makeKeyAndVisible()
    }
}</code></pre>
<h3 id="📌-코드-설명"><strong>📌 코드 설명</strong></h3>
<ol>
<li><code>UIWindowScene</code>을 가져와서 <code>UIWindow</code>를 생성.</li>
<li><code>UIScreen.main.bounds</code>를 사용하여 <strong>화면 크기에 맞게 UIWindow 크기 설정</strong>.</li>
<li><code>window?.rootViewController = ViewController()</code>  <ul>
<li><strong>앱의 첫 화면을 표시할 뷰 컨트롤러 지정</strong>.</li>
</ul>
</li>
<li><code>window?.makeKeyAndVisible()</code>  <ul>
<li><strong>UIWindow를 활성화하고, 앱 화면을 표시</strong>.</li>
</ul>
</li>
</ol>
<hr />
<h2 id="🔹-uiwindow의-주요-속성-및-메서드"><strong>🔹 UIWindow의 주요 속성 및 메서드</strong></h2>
<table>
<thead>
<tr>
<th>속성/메서드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><code>rootViewController</code></td>
<td>앱의 주요 화면을 담당하는 뷰 컨트롤러 설정</td>
</tr>
<tr>
<td><code>makeKeyAndVisible()</code></td>
<td>윈도우를 활성화하고, 화면에 표시</td>
</tr>
<tr>
<td><code>windowScene</code></td>
<td>현재 윈도우가 속한 <code>UIWindowScene</code></td>
</tr>
<tr>
<td><code>frame</code></td>
<td>윈도우의 크기 및 위치</td>
</tr>
<tr>
<td><code>isKeyWindow</code></td>
<td>현재 키 윈도우인지 확인 (사용자 입력을 받을 수 있는 윈도우)</td>
</tr>
</tbody></table>
<hr />
<h2 id="🔹-uiwindow와-view-hierarchy-뷰-계층-구조"><strong>🔹 UIWindow와 View Hierarchy (뷰 계층 구조)</strong></h2>
<pre><code class="language-swift">UIWindow
 ├── Root View Controller (예: UINavigationController)
      ├── ViewController1 (첫 번째 화면)
      ├── ViewController2 (두 번째 화면)</code></pre>
<ul>
<li><strong>모든 뷰(View)는 UIWindow 내부에 존재해야 화면에 표시됨.</strong></li>
<li><code>rootViewController</code>는 앱의 <strong>초기 화면을 담당</strong>하며, 내비게이션 흐름을 관리할 수 있음.</li>
</ul>
<hr />
<h2 id="📌-정리-4"><strong>📌 정리</strong></h2>
<ol>
<li><code>UIWindow</code>는 <strong>iOS 앱에서 UI를 표시하는 최상위 컨테이너</strong>.</li>
<li><code>UIWindow</code>는 <strong>앱의 루트 뷰 컨트롤러(Root View Controller)를 포함</strong>.</li>
<li>앱 실행 시 자동으로 생성되지만, 필요하면 코드로 직접 설정 가능.</li>
<li>사용자 <strong>입력 이벤트를 받아 적절한 뷰나 뷰 컨트롤러로 전달</strong>.</li>
<li>iOS 13부터는 <strong>멀티 윈도우를 지원</strong>하며, 각 Scene마다 <code>UIWindow</code>를 가질 수 있음.</li>
</ol>
<p>이제 <code>UIWindow</code>의 역할과 구현 방법을 확실히 이해할 수 있습니다! 🚀</p>
<hr />
<h1 id="📌-부모-뷰superview와-자식-뷰subview-개념-정리"><strong>📌 부모 뷰(Superview)와 자식 뷰(Subview) 개념 정리</strong></h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/2bb13712-a534-42b9-b4b4-84b96300cf92/image.png" /></p>
<p>iOS에서 <strong>뷰(View)는 계층 구조(Hierarchy)로 구성</strong>되며, <strong>부모 뷰(Superview)와 자식 뷰(Subview)</strong> 개념을 기반으로 UI를 구성합니다.</p>
<hr />
<h2 id="🔹-주요-개념"><strong>🔹 주요 개념</strong></h2>
<ol>
<li><p><strong>Subview(서브뷰)</strong></p>
<ul>
<li><strong>부모 뷰 안에서만 표시됨</strong> (항상 부모 뷰의 영역 내에 존재).</li>
<li>예: 버튼(UIButton)은 부모인 UIView 위에 표시됨.</li>
<li>부모 뷰의 크기가 변경되면, 서브뷰의 크기도 영향을 받을 수 있음.</li>
</ul>
</li>
<li><p><strong>Superview(수퍼뷰)</strong></p>
<ul>
<li><strong>자식 뷰(Subview)들을 포함하는 뷰</strong>.</li>
<li><strong>서브뷰의 위치 및 크기를 변경할 수 있음</strong>.</li>
<li>예: <code>UIView1</code>이 <code>UIView2</code>를 포함하면 <code>UIView1</code>이 <code>UIView2</code>의 부모 뷰(Superview).</li>
</ul>
</li>
</ol>
<hr />
<h2 id="🔹-ios-뷰-계층-구조-예시"><strong>🔹 iOS 뷰 계층 구조 예시</strong></h2>
<pre><code>UIWindow
 ├── UIView1 (슈퍼뷰)
 │    ├── UIButton1 (서브뷰)
 │    ├── UILabel (서브뷰)
 │    ├── UIView2 (서브뷰, UIView1의 자식)
 │         ├── UIButton2 (UIView2의 자식)
 │         ├── UIImageView (UIView2의 자식)</code></pre><ul>
<li><code>UIView1</code> → <code>UIButton1</code>, <code>UILabel</code>, <code>UIView2</code>를 포함.</li>
<li><code>UIView2</code>는 <code>UIButton2</code>, <code>UIImageView</code>를 포함 (자신도 <code>UIView1</code>의 서브뷰).</li>
<li>최상위 요소는 <strong>UIWindow</strong> (모든 뷰의 최상위 컨테이너).</li>
</ul>
<hr />
<h2 id="🔹-뷰-계층-코드-예제"><strong>🔹 뷰 계층 코드 예제</strong></h2>
<h3 id="✅-부모-뷰에-자식-뷰-추가"><strong>✅ 부모 뷰에 자식 뷰 추가</strong></h3>
<pre><code class="language-swift">let parentView = UIView(frame: CGRect(x: 50, y: 50, width: 200, height: 200))
parentView.backgroundColor = .blue

let childView = UIView(frame: CGRect(x: 20, y: 20, width: 100, height: 100))
childView.backgroundColor = .yellow

// 부모 뷰에 자식 뷰 추가
parentView.addSubview(childView)</code></pre>
<ul>
<li><code>parentView</code> 안에 <code>childView</code>가 포함됨.</li>
<li><code>childView</code>는 <code>parentView</code>의 <strong>서브뷰</strong>.</li>
<li><code>parentView</code>가 이동하면, <code>childView</code>도 함께 이동.</li>
</ul>
<hr />
<h3 id="🔹-뷰의-부모superview-및-자식subview-확인"><strong>🔹 뷰의 부모(Superview) 및 자식(Subview) 확인</strong></h3>
<pre><code class="language-swift">// 특정 뷰의 부모 뷰 가져오기
if let superview = childView.superview {
    print(&quot;부모 뷰는 \(superview)입니다.&quot;)
}

// 특정 뷰의 모든 자식 뷰 가져오기
print(&quot;UIView1의 서브뷰: \(parentView.subviews)&quot;)</code></pre>
<ul>
<li><code>superview</code> 속성을 사용하면 <strong>현재 뷰의 부모(Superview)를 가져올 수 있음</strong>.</li>
<li><code>subviews</code> 속성을 사용하면 <strong>해당 뷰의 모든 자식(Subview) 목록을 가져올 수 있음</strong>.</li>
</ul>
<hr />
<h2 id="📌-부모-자식-뷰의-크기-및-위치-변경"><strong>📌 부모-자식 뷰의 크기 및 위치 변경</strong></h2>
<h3 id="✅-부모-뷰-크기-변경-시-서브뷰-영향"><strong>✅ 부모 뷰 크기 변경 시 서브뷰 영향</strong></h3>
<pre><code class="language-swift">parentView.frame = CGRect(x: 50, y: 50, width: 300, height: 300)</code></pre>
<ul>
<li><code>parentView</code>의 크기가 변경되면, 서브뷰도 자동으로 영향을 받을 수 있음.</li>
</ul>
<h3 id="✅-서브뷰-위치-변경"><strong>✅ 서브뷰 위치 변경</strong></h3>
<pre><code class="language-swift">childView.frame.origin = CGPoint(x: 30, y: 30)</code></pre>
<ul>
<li><code>childView</code>의 위치를 변경하면 <strong>부모 뷰 내에서만 이동 가능</strong>.</li>
</ul>
<hr />
<h2 id="📌-정리-5"><strong>📌 정리</strong></h2>
<ol>
<li><strong>모든 뷰(View)는 부모 뷰(Superview)와 자식 뷰(Subview) 관계를 가짐.</strong></li>
<li>부모 뷰(<code>superview</code>) 안에 여러 개의 자식 뷰(<code>subviews</code>)를 포함할 수 있음.</li>
<li><strong>뷰 계층을 이용해 UI의 위치 관계와 그리기 순서를 결정</strong>.</li>
<li>부모 뷰 크기가 변경되면 <strong>서브뷰도 영향을 받을 수 있음</strong>.</li>
<li><code>addSubview()</code>, <code>superview</code>, <code>subviews</code> 등을 사용하여 뷰를 동적으로 조작 가능.</li>
</ol>
<p>UIView 계층 구조를 이해하면 <strong>iOS UI 개발을 효율적으로 구성할 수 있습니다!</strong> 🚀</p>
<hr />
<h1 id="📌-컨테이너-뷰container-view-개념"><strong>📌 컨테이너 뷰(Container View) 개념</strong></h1>
<p>컨테이너 뷰는 <strong>여러 개의 뷰 컨트롤러를 포함하고, 그 사이를 전환하는 역할을 수행하는 뷰 컨트롤러</strong>입니다.<br />즉, 하나의 컨테이너 컨트롤러가 여러 개의 화면을 관리하고, 사용자의 선택에 따라 <strong>뷰 컨트롤러 간 전환을 쉽게 처리할 수 있도록 도와줍니다</strong>.</p>
<hr />
<h1 id="📌-주요-컨테이너-뷰-컨트롤러"><strong>📌 주요 컨테이너 뷰 컨트롤러</strong></h1>
<h2 id="1️⃣-uinavigationcontroller-계층적-네비게이션"><strong>1️⃣ UINavigationController (계층적 네비게이션)</strong></h2>
<h3 id="📌-개념"><strong>📌 개념</strong></h3>
<ul>
<li>뷰 컨트롤러 간 <strong>계층적(Hierarchical) 네비게이션</strong>을 관리.</li>
<li>리스트에서 항목을 선택하면 <strong>새로운 화면을 <code>push</code>하여 상세 정보를 표시</strong>.</li>
<li>사용자가 <strong>뒤로 가기(Back Button)</strong> 를 눌러 이전 화면으로 돌아갈 수 있도록 지원.</li>
<li>iOS의 설정 앱이나 연락처 앱에서 사용되는 구조.</li>
</ul>
<h3 id="📌-기본-동작"><strong>📌 기본 동작</strong></h3>
<ol>
<li><code>pushViewController(_:animated:)</code> → <strong>새로운 화면 추가</strong> (전진)</li>
<li><code>popViewController(animated:)</code> → <strong>현재 화면을 닫고 이전 화면으로 돌아감</strong> (후진)</li>
</ol>
<h3 id="✅-예제-코드"><strong>✅ 예제 코드</strong></h3>
<pre><code class="language-swift">// 새로운 화면(ViewController2)으로 이동
let secondVC = ViewController2()
navigationController?.pushViewController(secondVC, animated: true)

// 현재 화면을 닫고 이전 화면으로 돌아감
navigationController?.popViewController(animated: true)</code></pre>
<hr />
<h2 id="2️⃣-uitabbarcontroller-탭-네비게이션"><strong>2️⃣ UITabBarController (탭 네비게이션)</strong></h2>
<h3 id="📌-개념-1"><strong>📌 개념</strong></h3>
<ul>
<li>뷰 컨트롤러 간의 <strong>평행적인(Navigational Parallel) 전환을 관리</strong>.</li>
<li>앱의 주요 기능을 <strong>각각의 탭(Tab)으로 구분</strong>하여 사용자가 선택할 수 있도록 함.</li>
<li>하단에 <strong>탭 바(Tab Bar)</strong> 가 표시되며, 사용자가 원하는 화면으로 즉시 전환 가능.</li>
</ul>
<h3 id="📌-기본-동작-1"><strong>📌 기본 동작</strong></h3>
<ul>
<li>각각의 <strong>탭(Tab)은 독립적인 뷰 컨트롤러</strong>를 가짐.</li>
<li>사용자는 원하는 탭을 선택하여 화면을 변경할 수 있음.</li>
</ul>
<h3 id="✅-예제-코드-1"><strong>✅ 예제 코드</strong></h3>
<pre><code class="language-swift">let tabBarController = UITabBarController()

let homeVC = HomeViewController()
let settingsVC = SettingsViewController()

// 각 뷰 컨트롤러에 탭 아이콘과 제목 설정
homeVC.tabBarItem = UITabBarItem(title: &quot;홈&quot;, image: UIImage(systemName: &quot;house&quot;), tag: 0)
settingsVC.tabBarItem = UITabBarItem(title: &quot;설정&quot;, image: UIImage(systemName: &quot;gear&quot;), tag: 1)

// 탭 바 컨트롤러에 뷰 컨트롤러 설정
tabBarController.viewControllers = [homeVC, settingsVC]</code></pre>
<hr />
<h2 id="3️⃣-uisplitviewcontroller-마스터-디테일-레이아웃"><strong>3️⃣ UISplitViewController (마스터-디테일 레이아웃)</strong></h2>
<h3 id="📌-개념-2"><strong>📌 개념</strong></h3>
<ul>
<li><strong>iPad에서 많이 사용되는 2단 화면 인터페이스</strong>.</li>
<li><strong>마스터 뷰(왼쪽)와 디테일 뷰(오른쪽)를 동시에 표시</strong>.</li>
<li>사용자가 <strong>목록에서 항목을 선택하면 오른쪽 상세 화면에 내용이 표시됨</strong>.</li>
<li>큰 화면을 가진 <strong>iPad, Mac Catalyst</strong> 환경에서 주로 사용됨.</li>
</ul>
<h3 id="📌-기본-동작-2"><strong>📌 기본 동작</strong></h3>
<ul>
<li><strong>Primary View (마스터 화면)</strong>: 목록을 표시.</li>
<li><strong>Secondary View (디테일 화면)</strong>: 선택한 목록의 상세 정보를 표시.</li>
</ul>
<h3 id="✅-예제-코드-2"><strong>✅ 예제 코드</strong></h3>
<pre><code class="language-swift">let splitVC = UISplitViewController(style: .doubleColumn)
let masterVC = MasterViewController()
let detailVC = DetailViewController()

splitVC.setViewController(masterVC, for: .primary)
splitVC.setViewController(detailVC, for: .secondary)

// 앱의 루트 뷰 컨트롤러로 설정
window?.rootViewController = splitVC</code></pre>
<hr />
<h1 id="📌-컨테이너-뷰-컨트롤러-비교"><strong>📌 컨테이너 뷰 컨트롤러 비교</strong></h1>
<table>
<thead>
<tr>
<th>컨트롤러</th>
<th>역할</th>
<th>사용 예시</th>
</tr>
</thead>
<tbody><tr>
<td><strong>UINavigationController</strong></td>
<td><strong>계층적(Hierarchical) 네비게이션</strong></td>
<td>리스트 → 상세 화면 이동</td>
</tr>
<tr>
<td><strong>UITabBarController</strong></td>
<td><strong>평행적(Navigational Parallel) 네비게이션</strong></td>
<td>홈/설정/프로필 같은 독립적인 화면 구성</td>
</tr>
<tr>
<td><strong>UISplitViewController</strong></td>
<td><strong>마스터-디테일 레이아웃</strong></td>
<td>iPad에서 목록-상세 화면 구성</td>
</tr>
</tbody></table>
<p><strong>컨테이너 뷰 컨트롤러를 적절히 활용하면 iOS 앱의 화면 전환 및 UI 구성을 더욱 효율적으로 관리할 수 있습니다!</strong> 🚀</p>
<hr />
<h1 id="auto-layout">Auto Layout</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/9312a074-19b3-45e4-b0a2-9079874f8b3d/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/1ed98397-e767-4419-95a1-447fcf8f5035/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/d715f3fe-9e16-41b8-b8b3-6a9ec61dbc9f/image.png" /></p>
<p>iOS에서 <strong>Auto Layout(오토 레이아웃)</strong>은 <strong>화면 크기가 달라져도 버튼, 이미지, 글씨 같은 UI 요소들이 원하는 위치에 유지되도록 도와주는 시스템</strong>입니다.  </p>
<hr />
<h2 id="1️⃣-왜-auto-layout이-필요할까"><strong>1️⃣ 왜 Auto Layout이 필요할까?</strong></h2>
<p>앱을 만들 때 화면에 <strong>버튼, 이미지, 글씨</strong> 같은 것들을 배치해야 합니다.<br />하지만 아이폰에는 <strong>크기가 다양한 기기</strong>가 있습니다.<br />📱 iPhone SE (작음)<br />📱 iPhone 14 Pro Max (큼)<br />📱 iPad (더 큼)  </p>
<p>👉 <strong>각각의 화면 크기에 맞춰서 UI를 일일이 조정하는 건 불가능합니다!</strong><br />👉 화면 크기가 다르더라도 <strong>자동으로 조절되도록 하는 방법이 필요합니다.</strong>  </p>
<p>💡 그래서 <strong>Auto Layout을 사용하면, 화면 크기에 따라 버튼과 텍스트가 자동으로 배치됩니다!</strong></p>
<hr />
<h2 id="2️⃣-auto-layout은-어떻게-동작할까"><strong>2️⃣ Auto Layout은 어떻게 동작할까?</strong></h2>
<p>Auto Layout은 <strong>제약(Constraints, 컨스트레인트)</strong> 이라는 규칙을 사용합니다.<br />이 규칙을 통해 <strong>버튼, 이미지 등의 위치와 크기를 정할 수 있습니다.</strong></p>
<h3 id="✅-예제-버튼을-화면-중앙에-배치하기"><strong>✅ 예제: 버튼을 화면 중앙에 배치하기</strong></h3>
<ol>
<li><strong>X 좌표(가로 방향) → &quot;가운데 정렬&quot;</strong></li>
<li><strong>Y 좌표(세로 방향) → &quot;가운데 정렬&quot;</strong><br />이렇게 제약을 설정하면, <strong>어떤 기기에서도 버튼이 항상 화면 중앙에 위치</strong>합니다.</li>
</ol>
<pre><code class="language-swift">button.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
button.centerYAnchor.constraint(equalTo: view.centerYAnchor).isActive = true</code></pre>
<hr />
<h2 id="3️⃣-auto-layout의-주요-개념"><strong>3️⃣ Auto Layout의 주요 개념</strong></h2>
<h3 id="✅-1-고정된-위치--크기"><strong>✅ 1. 고정된 위치 &amp; 크기</strong></h3>
<ul>
<li>&quot;이 버튼을 <strong>왼쪽에서 20pt 떨어진 위치에 두겠다</strong>&quot;</li>
<li>&quot;이 버튼을 <strong>너비 100pt, 높이 50pt로 고정하겠다</strong>&quot;</li>
</ul>
<pre><code class="language-swift">button.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20).isActive = true
button.widthAnchor.constraint(equalToConstant: 100).isActive = true
button.heightAnchor.constraint(equalToConstant: 50).isActive = true</code></pre>
<h3 id="✅-2-상대적인-위치"><strong>✅ 2. 상대적인 위치</strong></h3>
<ul>
<li>&quot;이 버튼을 <strong>다른 버튼 아래에 배치하겠다</strong>&quot;</li>
<li>&quot;이 버튼을 <strong>화면 크기에 비례해서 크기를 정하겠다</strong>&quot;</li>
</ul>
<pre><code class="language-swift">button.topAnchor.constraint(equalTo: anotherButton.bottomAnchor, constant: 20).isActive = true
button.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.5).isActive = true</code></pre>
<hr />
<h2 id="4️⃣-auto-layout-없으면-어떻게-될까"><strong>4️⃣ Auto Layout 없으면 어떻게 될까?</strong></h2>
<p>🚫 Auto Layout이 없으면?<br />✅ <strong>큰 아이폰에서는 버튼이 한쪽으로 붙고</strong>,  
✅ <strong>작은 아이폰에서는 버튼이 화면 밖으로 나가버릴 수도 있음</strong> 😱  </p>
<p>💡 <strong>Auto Layout을 사용하면, 어떤 화면에서도 UI가 깨지지 않음!</strong></p>
<hr />
<h2 id="5️⃣-auto-layout의-장점"><strong>5️⃣ Auto Layout의 장점</strong></h2>
<p>✔️ <strong>화면 크기가 달라도 UI가 깨지지 않음!</strong><br />✔️ <strong>코드를 직접 짜거나, Xcode의 Storyboard에서 설정 가능!</strong><br />✔️ <strong>모든 아이폰, 아이패드에서 UI를 자동으로 조정!</strong>  </p>
<hr />
<h2 id="📌-정리-6"><strong>📌 정리</strong></h2>
<ul>
<li><strong>Auto Layout이란?</strong><br />👉 화면 크기에 따라 UI가 자동으로 조정되도록 하는 기능  </li>
<li><strong>어떻게 동작할까?</strong><br />👉 <strong>제약(Constraints)</strong> 을 설정하여 <strong>위치, 크기, 간격을 정함</strong>  </li>
<li><strong>왜 중요할까?</strong><br />👉 <strong>아이폰 크기가 다 다르기 때문에, 모든 기기에서 UI가 올바르게 보이도록 해야 함!</strong>  </li>
<li><strong>사용 방법</strong><br />👉 Xcode의 <strong>Storyboard</strong> 또는 <strong>Swift 코드로 설정 가능!</strong>  </li>
</ul>
<p>🚀 <strong>Auto Layout을 이해하면, 어떤 화면 크기에서도 잘 동작하는 앱을 만들 수 있어요!</strong></p>
<hr />
<h1 id="📌-ios에서-auto-layout을-설정하는-방법의-장단점-비교"><strong>📌 iOS에서 Auto Layout을 설정하는 방법의 장단점 비교</strong></h1>
<table>
<thead>
<tr>
<th>방법</th>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Storyboard (Interface Builder 사용)</strong></td>
<td>- <strong>시각적으로 편리</strong>: UI 요소를 드래그하여 쉽게 배치 가능.  <br />- <strong>즉각적인 피드백</strong>: 실시간으로 레이아웃을 확인할 수 있음.  <br />- <strong>초보자 친화적</strong>: 코드를 거의 작성하지 않아도 됨.</td>
<td>- <strong>복잡한 레이아웃에서 관리 어려움</strong>: 많은 요소가 있을 경우 <strong>Auto Layout 충돌 발생 가능</strong>.  <br />- <strong>버전 관리 어려움</strong>: Git에서 변경 사항 비교가 어려움.  <br />- <strong>반복 작업 비효율적</strong>: 동일한 레이아웃을 여러 곳에서 사용할 경우 비효율적.</td>
</tr>
<tr>
<td><strong>코드 (NSLayoutConstraint 활용)</strong></td>
<td>- <strong>유연한 제어</strong>: <strong>조건문과 함께 사용 가능</strong>하여 상황에 따라 다른 제약 설정 가능.  <br />- <strong>Git 관리 용이</strong>: 코드 기반이라 변경 사항을 쉽게 추적 가능.  <br />- <strong>반복되는 UI 구성에 유리</strong>: 동일한 레이아웃을 여러 화면에서 활용 가능.</td>
<td>- <strong>초보자에게 어려움</strong>: 직접 제약을 추가해야 하므로 학습이 필요.  <br />- <strong>UI 변경 시 수정이 번거로움</strong>: 직접 코드를 변경해야 함.  <br />- <strong>직관적이지 않음</strong>: 코드만으로 UI를 파악하기 어려움.</td>
</tr>
<tr>
<td><strong>Visual Format Language (VFL) 사용</strong></td>
<td>- <strong>코드가 간결함</strong>: 한 줄로 여러 개의 제약을 설정 가능.  <br />- <strong>가독성이 높음</strong>: Auto Layout을 선언적으로 표현할 수 있음.</td>
<td>- <strong>유연성이 부족함</strong>: 복잡한 레이아웃에는 적합하지 않음.  <br />- <strong>제약을 디버깅하기 어려움</strong>: 문자열로 작성되기 때문에 오류 발생 시 원인 찾기가 어려움.</td>
</tr>
<tr>
<td><strong>SnapKit (Auto Layout을 위한 서드파티 라이브러리)</strong></td>
<td>- <strong>코드 가독성 높음</strong>: 제약 조건을 직관적으로 설정 가능.  <br />- <strong>생산성 증가</strong>: NSLayoutConstraint보다 코드 작성이 훨씬 간편.</td>
<td>- <strong>추가 라이브러리 필요</strong>: 프로젝트에 SnapKit을 설치해야 함.  <br />- <strong>스토리보드와 병행 사용 어려움</strong>: 코드 기반 Auto Layout만 지원.</td>
</tr>
</tbody></table>
<hr />
<h3 id="📌-결론-1"><strong>📌 결론</strong></h3>
<ul>
<li>초보자 → <strong>Storyboard 사용</strong>이 편리하지만, <strong>복잡한 레이아웃에서는 제약이 많음</strong>.</li>
<li>중급 이상 → <strong>코드(NSLayoutConstraint) 사용</strong>이 유리하며, <strong>Git 관리 및 유지보수 측면에서도 장점</strong>.</li>
<li>간결한 코드 선호 → <strong>SnapKit</strong> 사용.</li>
<li>간단한 UI 레이아웃 정의 → <strong>VFL</strong> 사용 가능하지만 활용도가 낮음.</li>
</ul>
<p>🚀 <strong>상황에 따라 적절한 Auto Layout 방법을 선택하면 더욱 효율적인 iOS UI 개발이 가능합니다!</strong> 😊</p>
<hr />
<h1 id="전광판-앱-만들기">전광판 앱 만들기</h1>
<p><img alt="" src="https://velog.velcdn.com/images/kyk02405/post/a0d83e96-bdbd-4a1c-82d8-e375c6e580ab/image.png" /></p>